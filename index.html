<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>Only for you</title>
  <link rel="icon" href="main.ico" type="image/x-icon">
  <style>
    @font-face {
      font-family: 'Imperial Script';
      src: url('Font.ttf') format('truetype');
      font-display: swap;
    }
    body {
      margin: 0; 
      background: #000; 
      color: #FFD700; 
      font-family: 'Imperial Script', cursive; 
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }
    #three-container {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 10;
    }
    #sound-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 100;
      background: rgba(0,0,0,0.5);
      border: 2px solid #FFD700;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: #FFD700;
      font-size: 24px;
      box-shadow: 0 0 10px #FFD700;
    }
  </style>
</head>
<body>

  <div id="three-container"></div>
  <div id="sound-toggle">ðŸ”‡</div>

  <audio id="bgm" src="sound.mp3" loop></audio>

  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>

  <script>
    const threeContainer = document.getElementById('three-container');
    const bgm = document.getElementById('bgm');
    const soundToggle = document.getElementById('sound-toggle');

    let isSoundOn = false;

    // Show 3D canvas and sound toggle immediately
    threeContainer.style.display = 'block';
    soundToggle.style.display = 'flex';

    // Sound toggle functionality
    soundToggle.addEventListener('click', () => {
      isSoundOn = !isSoundOn;
      if (isSoundOn) {
        bgm.play().catch(e => console.log('Audio play failed:', e));
        soundToggle.textContent = 'ðŸ”Š';
      } else {
        bgm.pause();
        soundToggle.textContent = 'ðŸ”‡';
      }
    });

    // --- ThreeJS code ---
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    threeContainer.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    // Stars
    const starsGeometry = new THREE.BufferGeometry();
    const starsVertices = [];
    for (let i = 0; i < 2000; i++) {
      starsVertices.push((Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000);
    }
    starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
    const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.3 });
    const stars = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(stars);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
    camera.position.z = 100;

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const loiChuc = [
      "Anh yÃªu em", "Iu em mÃ²", "Nhá»› em gÃ²i", "ThÆ¡m tui miáº¿ng", "YÃªu em Linh", "Miss you so much",
      "Anh yÃªu em", "Iu em mÃ²", "Nhá»› em gÃ²i", "ThÆ¡m tui miáº¿ng", "YÃªu em Linh", "Miss you so much",
      "Anh yÃªu em", "Iu em mÃ²", "Nhá»› em gÃ²i", "ThÆ¡m tui miáº¿ng", "YÃªu em Linh", "Miss you so much",

      "Nhá»› em gÃ²i", "Khoa qua Ä‘Ã³n em nha", "ui ui ui",
      "Linh tháº¥y sao Linh", "Em iu Æ¡iiiiii", "Ai mÃ  xinh thÃ©eeee",
      "Khoa lÃ m ngÆ°á»i iu em nha", "dá»… thÆ°Æ¡ng hÄƒm", "Can we tie the knot?",
      "á»Žooo", "Äá»• rá»“i Linh Æ¡i", "Hai má»™t cÃºn",
    ];

    const textCards = [];
    const basePositions = [];

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    const createTextCard = (text, x, y, z) => {
      const canvas = document.createElement('canvas');
      canvas.width = 1300;
      canvas.height = 600;
      const ctx = canvas.getContext('2d');

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.shadowColor = "#FFD700";
      ctx.shadowBlur = 80;
      ctx.fillStyle = "#FFFFFF";
      ctx.font = "bold 170px 'Imperial Script', cursive";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);

      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        opacity: 0.95,
        side: THREE.DoubleSide,
        depthWrite: false
      });

      const geometry = new THREE.PlaneGeometry(14, 7);
      const card = new THREE.Mesh(geometry, material);
      card.position.set(x, y, z);
      scene.add(card);

      textCards.push(card);
      basePositions.push(new THREE.Vector3(x, y, z));
    };

    for (let i = 0; i < 400; i++) {
      const text = loiChuc[Math.floor(Math.random() * loiChuc.length)];
      const radius = 180 * Math.cbrt(Math.random());
      const theta = Math.random() * 2 * Math.PI;
      const phi = Math.acos(2 * Math.random() - 1);
      const x = radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.sin(phi) * Math.sin(theta);
      const z = radius * Math.cos(phi);
      createTextCard(text, x, y, z);
    }

    let clock = new THREE.Clock();
    let INTERSECTED = null;

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      let t = clock.getElapsedTime();

      // Floating text animation
      textCards.forEach((card, i) => {
        const base = basePositions[i];
        card.position.y = base.y + Math.sin(t + i) * 1.5;
        if (card !== INTERSECTED) {
          card.scale.set(1, 1, 1);
        }
      });

      // Hover detection
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(textCards);
      if (intersects.length > 0) {
        const hovered = intersects[0].object;
        hovered.scale.set(1.3, 1.3, 1.3);
        INTERSECTED = hovered;
      } else {
        INTERSECTED = null;
      }

      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('mousemove', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
