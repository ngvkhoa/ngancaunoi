<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>Only for you</title>
  <link rel="icon" href="main.ico" type="image/x-icon">
  <style>
    @font-face {
      font-family: 'Imperial Script';
      src: url('Font.ttf') format('truetype');
      font-display: swap;
    }
    body {
      margin: 0; 
      background: #000; 
      color: #FFD700; 
      font-family: 'Imperial Script', cursive; 
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }
    #three-container {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 10;
    }
    #sound-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 100;
      background: rgba(0,0,0,0.5);
      border: 2px solid #FFD700;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: #FFD700;
      font-size: 24px;
      box-shadow: 0 0 10px #FFD700;
    }
  </style>
</head>
<body>

  <div id="three-container"></div>
  <div id="sound-toggle">🔇</div>

  <audio id="bgm" src="sound.mp3" loop></audio>

  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>

  <script>
    const threeContainer = document.getElementById('three-container');
    const bgm = document.getElementById('bgm');
    const soundToggle = document.getElementById('sound-toggle');

    let isSoundOn = false;

    // Show 3D canvas and sound toggle immediately
    threeContainer.style.display = 'block';
    soundToggle.style.display = 'flex';

    // Sound toggle functionality
    soundToggle.addEventListener('click', () => {
      isSoundOn = !isSoundOn;
      if (isSoundOn) {
        bgm.play().catch(e => console.log('Audio play failed:', e));
        soundToggle.textContent = '🔊';
      } else {
        bgm.pause();
        soundToggle.textContent = '🔇';
      }
    });

    // --- ThreeJS code ---
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    threeContainer.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    // Stars
    const starsGeometry = new THREE.BufferGeometry();
    const starsVertices = [];
    for (let i = 0; i < 2000; i++) {
      starsVertices.push((Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000);
    }
    starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
    const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.3 });
    const stars = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(stars);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
    camera.position.z = 100;

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const loiChuc = [
      "Anh yêu em", "Iu em mò", "Nhớ em gòi", "Thơm tui miếng", "Yêu em Linh", "Miss you so much",
      "Anh yêu em", "Iu em mò", "Nhớ em gòi", "Thơm tui miếng", "Yêu em Linh", "Miss you so much",
      "Anh yêu em", "Iu em mò", "Nhớ em gòi", "Thơm tui miếng", "Yêu em Linh", "Miss you so much",

      "Nhớ em gòi", "Khoa qua đón em nha", "ui ui ui",
      "Linh thấy sao Linh", "Em iu ơiiiiii", "Ai mà xinh théeeee",
      "Khoa làm người iu em nha", "dễ thương hăm", "Can we tie the knot?",
      "Ỏooo", "Đổ rồi Linh ơi", "Hai một cún",
    ];

    const textCards = [];
    const basePositions = [];

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    const createTextCard = (text, x, y, z) => {
      const canvas = document.createElement('canvas');
      canvas.width = 1300;
      canvas.height = 600;
      const ctx = canvas.getContext('2d');

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.shadowColor = "#FFD700";
      ctx.shadowBlur = 80;
      ctx.fillStyle = "#FFFFFF";
      ctx.font = "bold 170px 'Imperial Script', cursive";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);

      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        opacity: 0.95,
        side: THREE.DoubleSide,
        depthWrite: false
      });

      const geometry = new THREE.PlaneGeometry(14, 7);
      const card = new THREE.Mesh(geometry, material);
      card.position.set(x, y, z);
      scene.add(card);

      textCards.push(card);
      basePositions.push(new THREE.Vector3(x, y, z));
    };

    for (let i = 0; i < 400; i++) {
      const text = loiChuc[Math.floor(Math.random() * loiChuc.length)];
      const radius = 180 * Math.cbrt(Math.random());
      const theta = Math.random() * 2 * Math.PI;
      const phi = Math.acos(2 * Math.random() - 1);
      const x = radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.sin(phi) * Math.sin(theta);
      const z = radius * Math.cos(phi);
      createTextCard(text, x, y, z);
    }

    let clock = new THREE.Clock();
    let INTERSECTED = null;

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      let t = clock.getElapsedTime();

      // Floating text animation
      textCards.forEach((card, i) => {
        const base = basePositions[i];
        card.position.y = base.y + Math.sin(t + i) * 1.5;
        if (card !== INTERSECTED) {
          card.scale.set(1, 1, 1);
        }
      });

      // Hover detection
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(textCards);
      if (intersects.length > 0) {
        const hovered = intersects[0].object;
        hovered.scale.set(1.3, 1.3, 1.3);
        INTERSECTED = hovered;
      } else {
        INTERSECTED = null;
      }

      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('mousemove', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
